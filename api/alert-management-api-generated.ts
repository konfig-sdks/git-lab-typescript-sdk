/* tslint:disable */
/* eslint-disable */
/*
GitLab API

An OpenAPI definition for the GitLab REST API.
Few API resources or endpoints are currently included.
The intent is to expand this to match the entire Markdown documentation of the API:
<https://docs.gitlab.com/ee/api/>. Contributions are welcome.

When viewing this on gitlab.com, you can test API calls directly from the browser
against the `gitlab.com` instance, if you are logged in.
The feature uses the current [GitLab session cookie](https://docs.gitlab.com/ee/api/index.html#session-cookie),
so each request is made using your account.

Instructions for using this tool can be found in [Interactive API Documentation](https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html)


The version of the OpenAPI document: v4


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { APIEntitiesMetricImage } from '../models';
// @ts-ignore
import { AlertmanagementUpdateMetricImageRequest } from '../models';
// @ts-ignore
import { AlertmanagementUploadMetricImageRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AlertManagementApi - axios parameter creator
 * @export
 */
export const AlertManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Workhorse authorize metric image file upload
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} alertIid The IID of the Alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeMetricImageUpload: async (id: string, alertIid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authorizeMetricImageUpload', 'id', id)
            // verify required parameter 'alertIid' is not null or undefined
            assertParamExists('authorizeMetricImageUpload', 'alertIid', alertIid)
            const localVarPath = `/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/authorize`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"alert_iid"}}`, encodeURIComponent(String(alertIid !== undefined ? alertIid : `-alert_iid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/authorize',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Metric Images for alert
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} alertIid The IID of the Alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricImagesForAlert: async (id: string, alertIid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMetricImagesForAlert', 'id', id)
            // verify required parameter 'alertIid' is not null or undefined
            assertParamExists('getMetricImagesForAlert', 'alertIid', alertIid)
            const localVarPath = `/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"alert_iid"}}`, encodeURIComponent(String(alertIid !== undefined ? alertIid : `-alert_iid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a metric image for an alert
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} alertIid The IID of the Alert
         * @param {number} metricImageId The ID of metric image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMetricImage: async (id: string, alertIid: number, metricImageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeMetricImage', 'id', id)
            // verify required parameter 'alertIid' is not null or undefined
            assertParamExists('removeMetricImage', 'alertIid', alertIid)
            // verify required parameter 'metricImageId' is not null or undefined
            assertParamExists('removeMetricImage', 'metricImageId', metricImageId)
            const localVarPath = `/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/{metric_image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"alert_iid"}}`, encodeURIComponent(String(alertIid !== undefined ? alertIid : `-alert_iid-`)))
                .replace(`{${"metric_image_id"}}`, encodeURIComponent(String(metricImageId !== undefined ? metricImageId : `-metric_image_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/{metric_image_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a metric image for an alert
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} alertIid The IID of the Alert
         * @param {number} metricImageId The ID of metric image
         * @param {string} [url] The url to view more metric info
         * @param {string} [urlText] A description of the image or URL
         * @param {AlertmanagementUpdateMetricImageRequest} [alertmanagementUpdateMetricImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricImage: async (id: string, alertIid: number, metricImageId: number, url?: string, urlText?: string, alertmanagementUpdateMetricImageRequest?: AlertmanagementUpdateMetricImageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMetricImage', 'id', id)
            // verify required parameter 'alertIid' is not null or undefined
            assertParamExists('updateMetricImage', 'alertIid', alertIid)
            // verify required parameter 'metricImageId' is not null or undefined
            assertParamExists('updateMetricImage', 'metricImageId', metricImageId)
            const localVarPath = `/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/{metric_image_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"alert_iid"}}`, encodeURIComponent(String(alertIid !== undefined ? alertIid : `-alert_iid-`)))
                .replace(`{${"metric_image_id"}}`, encodeURIComponent(String(metricImageId !== undefined ? metricImageId : `-metric_image_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

            if (url !== undefined) {
                await addFormParam('url', url, false, true)
            }
    
            if (urlText !== undefined) {
                await addFormParam('url_text', urlText, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: alertmanagementUpdateMetricImageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images/{metric_image_id}',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a metric image for an alert
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} alertIid The IID of the Alert
         * @param {Uint8Array | File | buffer.File} file The image file to be uploaded
         * @param {AlertmanagementUploadMetricImageRequest} alertmanagementUploadMetricImageRequest 
         * @param {string} [url] The url to view more metric info
         * @param {string} [urlText] A description of the image or URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMetricImage: async (id: string, alertIid: number, file: Uint8Array | File | buffer.File, alertmanagementUploadMetricImageRequest: AlertmanagementUploadMetricImageRequest, url?: string, urlText?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadMetricImage', 'id', id)
            // verify required parameter 'alertIid' is not null or undefined
            assertParamExists('uploadMetricImage', 'alertIid', alertIid)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMetricImage', 'file', file)
            // verify required parameter 'alertmanagementUploadMetricImageRequest' is not null or undefined
            assertParamExists('uploadMetricImage', 'alertmanagementUploadMetricImageRequest', alertmanagementUploadMetricImageRequest)
            const localVarPath = `/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"alert_iid"}}`, encodeURIComponent(String(alertIid !== undefined ? alertIid : `-alert_iid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
            if (url !== undefined) {
                await addFormParam('url', url, false, true)
            }
    
            if (urlText !== undefined) {
                await addFormParam('url_text', urlText, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: alertmanagementUploadMetricImageRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/alert_management_alerts/{alert_iid}/metric_images',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertManagementApi - functional programming interface
 * @export
 */
export const AlertManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Workhorse authorize metric image file upload
         * @param {AlertManagementApiAuthorizeMetricImageUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeMetricImageUpload(requestParameters: AlertManagementApiAuthorizeMetricImageUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeMetricImageUpload(requestParameters.id, requestParameters.alertIid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Metric Images for alert
         * @param {AlertManagementApiGetMetricImagesForAlertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetricImagesForAlert(requestParameters: AlertManagementApiGetMetricImagesForAlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIEntitiesMetricImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricImagesForAlert(requestParameters.id, requestParameters.alertIid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a metric image for an alert
         * @param {AlertManagementApiRemoveMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMetricImage(requestParameters: AlertManagementApiRemoveMetricImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesMetricImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMetricImage(requestParameters.id, requestParameters.alertIid, requestParameters.metricImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a metric image for an alert
         * @param {AlertManagementApiUpdateMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMetricImage(requestParameters: AlertManagementApiUpdateMetricImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesMetricImage>> {
            const alertmanagementUpdateMetricImageRequest: AlertmanagementUpdateMetricImageRequest = {
                url: requestParameters.url,
                url_text: requestParameters.url_text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMetricImage(requestParameters.id, requestParameters.alertIid, requestParameters.metricImageId, requestParameters.url, requestParameters.urlText, alertmanagementUpdateMetricImageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a metric image for an alert
         * @param {AlertManagementApiUploadMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMetricImage(requestParameters: AlertManagementApiUploadMetricImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesMetricImage>> {
            const alertmanagementUploadMetricImageRequest: AlertmanagementUploadMetricImageRequest = {
                file: requestParameters.file,
                url: requestParameters.url,
                url_text: requestParameters.url_text
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMetricImage(requestParameters.id, requestParameters.alertIid, requestParameters.file, alertmanagementUploadMetricImageRequest, requestParameters.url, requestParameters.urlText, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertManagementApi - factory interface
 * @export
 */
export const AlertManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertManagementApiFp(configuration)
    return {
        /**
         * Workhorse authorize metric image file upload
         * @param {AlertManagementApiAuthorizeMetricImageUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeMetricImageUpload(requestParameters: AlertManagementApiAuthorizeMetricImageUploadRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorizeMetricImageUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Metric Images for alert
         * @param {AlertManagementApiGetMetricImagesForAlertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetricImagesForAlert(requestParameters: AlertManagementApiGetMetricImagesForAlertRequest, options?: AxiosRequestConfig): AxiosPromise<Array<APIEntitiesMetricImage>> {
            return localVarFp.getMetricImagesForAlert(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a metric image for an alert
         * @param {AlertManagementApiRemoveMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMetricImage(requestParameters: AlertManagementApiRemoveMetricImageRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesMetricImage> {
            return localVarFp.removeMetricImage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a metric image for an alert
         * @param {AlertManagementApiUpdateMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetricImage(requestParameters: AlertManagementApiUpdateMetricImageRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesMetricImage> {
            return localVarFp.updateMetricImage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a metric image for an alert
         * @param {AlertManagementApiUploadMetricImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMetricImage(requestParameters: AlertManagementApiUploadMetricImageRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesMetricImage> {
            return localVarFp.uploadMetricImage(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorizeMetricImageUpload operation in AlertManagementApi.
 * @export
 * @interface AlertManagementApiAuthorizeMetricImageUploadRequest
 */
export type AlertManagementApiAuthorizeMetricImageUploadRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof AlertManagementApiAuthorizeMetricImageUpload
    */
    readonly id: string
    
    /**
    * The IID of the Alert
    * @type {number}
    * @memberof AlertManagementApiAuthorizeMetricImageUpload
    */
    readonly alertIid: number
    
}

/**
 * Request parameters for getMetricImagesForAlert operation in AlertManagementApi.
 * @export
 * @interface AlertManagementApiGetMetricImagesForAlertRequest
 */
export type AlertManagementApiGetMetricImagesForAlertRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof AlertManagementApiGetMetricImagesForAlert
    */
    readonly id: string
    
    /**
    * The IID of the Alert
    * @type {number}
    * @memberof AlertManagementApiGetMetricImagesForAlert
    */
    readonly alertIid: number
    
}

/**
 * Request parameters for removeMetricImage operation in AlertManagementApi.
 * @export
 * @interface AlertManagementApiRemoveMetricImageRequest
 */
export type AlertManagementApiRemoveMetricImageRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof AlertManagementApiRemoveMetricImage
    */
    readonly id: string
    
    /**
    * The IID of the Alert
    * @type {number}
    * @memberof AlertManagementApiRemoveMetricImage
    */
    readonly alertIid: number
    
    /**
    * The ID of metric image
    * @type {number}
    * @memberof AlertManagementApiRemoveMetricImage
    */
    readonly metricImageId: number
    
}

/**
 * Request parameters for updateMetricImage operation in AlertManagementApi.
 * @export
 * @interface AlertManagementApiUpdateMetricImageRequest
 */
export type AlertManagementApiUpdateMetricImageRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof AlertManagementApiUpdateMetricImage
    */
    readonly id: string
    
    /**
    * The IID of the Alert
    * @type {number}
    * @memberof AlertManagementApiUpdateMetricImage
    */
    readonly alertIid: number
    
    /**
    * The ID of metric image
    * @type {number}
    * @memberof AlertManagementApiUpdateMetricImage
    */
    readonly metricImageId: number
    
    /**
    * The url to view more metric info
    * @type {string}
    * @memberof AlertManagementApiUpdateMetricImage
    */
    readonly url?: string
    
    /**
    * A description of the image or URL
    * @type {string}
    * @memberof AlertManagementApiUpdateMetricImage
    */
    readonly urlText?: string
    
} & AlertmanagementUpdateMetricImageRequest

/**
 * Request parameters for uploadMetricImage operation in AlertManagementApi.
 * @export
 * @interface AlertManagementApiUploadMetricImageRequest
 */
export type AlertManagementApiUploadMetricImageRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof AlertManagementApiUploadMetricImage
    */
    readonly id: string
    
    /**
    * The IID of the Alert
    * @type {number}
    * @memberof AlertManagementApiUploadMetricImage
    */
    readonly alertIid: number
    
    /**
    * The image file to be uploaded
    * @type {Uint8Array | File | buffer.File}
    * @memberof AlertManagementApiUploadMetricImage
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * The url to view more metric info
    * @type {string}
    * @memberof AlertManagementApiUploadMetricImage
    */
    readonly url?: string
    
    /**
    * A description of the image or URL
    * @type {string}
    * @memberof AlertManagementApiUploadMetricImage
    */
    readonly urlText?: string
    
} & AlertmanagementUploadMetricImageRequest

/**
 * AlertManagementApiGenerated - object-oriented interface
 * @export
 * @class AlertManagementApiGenerated
 * @extends {BaseAPI}
 */
export class AlertManagementApiGenerated extends BaseAPI {
    /**
     * Workhorse authorize metric image file upload
     * @param {AlertManagementApiAuthorizeMetricImageUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertManagementApiGenerated
     */
    public authorizeMetricImageUpload(requestParameters: AlertManagementApiAuthorizeMetricImageUploadRequest, options?: AxiosRequestConfig) {
        return AlertManagementApiFp(this.configuration).authorizeMetricImageUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Metric Images for alert
     * @param {AlertManagementApiGetMetricImagesForAlertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertManagementApiGenerated
     */
    public getMetricImagesForAlert(requestParameters: AlertManagementApiGetMetricImagesForAlertRequest, options?: AxiosRequestConfig) {
        return AlertManagementApiFp(this.configuration).getMetricImagesForAlert(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a metric image for an alert
     * @param {AlertManagementApiRemoveMetricImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertManagementApiGenerated
     */
    public removeMetricImage(requestParameters: AlertManagementApiRemoveMetricImageRequest, options?: AxiosRequestConfig) {
        return AlertManagementApiFp(this.configuration).removeMetricImage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a metric image for an alert
     * @param {AlertManagementApiUpdateMetricImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertManagementApiGenerated
     */
    public updateMetricImage(requestParameters: AlertManagementApiUpdateMetricImageRequest, options?: AxiosRequestConfig) {
        return AlertManagementApiFp(this.configuration).updateMetricImage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a metric image for an alert
     * @param {AlertManagementApiUploadMetricImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertManagementApiGenerated
     */
    public uploadMetricImage(requestParameters: AlertManagementApiUploadMetricImageRequest, options?: AxiosRequestConfig) {
        return AlertManagementApiFp(this.configuration).uploadMetricImage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
