/* tslint:disable */
/* eslint-disable */
/*
GitLab API

An OpenAPI definition for the GitLab REST API.
Few API resources or endpoints are currently included.
The intent is to expand this to match the entire Markdown documentation of the API:
<https://docs.gitlab.com/ee/api/>. Contributions are welcome.

When viewing this on gitlab.com, you can test API calls directly from the browser
against the `gitlab.com` instance, if you are logged in.
The feature uses the current [GitLab session cookie](https://docs.gitlab.com/ee/api/index.html#session-cookie),
so each request is made using your account.

Instructions for using this tool can be found in [Interactive API Documentation](https://docs.gitlab.com/ee/api/openapi/openapi_interactive.html)


The version of the OpenAPI document: v4


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { APIEntitiesBranch } from '../models';
// @ts-ignore
import { BranchesProtectBranchRequest } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a branch exists
         * @param {string} id The ID or URL-encoded path of the project
         * @param {string} branch The name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIfExists: async (id: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkIfExists', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('checkIfExists', 'branch', branch)
            const localVarPath = `/api/v4/projects/{id}/repository/branches/{branch}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch !== undefined ? branch : `-branch-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches/{branch}',
                httpMethod: 'HEAD'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create branch
         * @param {string} id The ID or URL-encoded path of the project
         * @param {string} branch The name of the branch
         * @param {string} ref Create branch from commit sha or existing branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranch: async (id: string, branch: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createBranch', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('createBranch', 'branch', branch)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('createBranch', 'ref', ref)
            const localVarPath = `/api/v4/projects/{id}/repository/branches`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })
            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a branch
         * @param {string} id The ID or URL-encoded path of the project
         * @param {string} branch The name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch: async (id: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBranch', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('deleteBranch', 'branch', branch)
            const localVarPath = `/api/v4/projects/{id}/repository/branches/{branch}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch !== undefined ? branch : `-branch-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches/{branch}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all merged branches
         * @param {string} id The ID or URL-encoded path of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerged: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMerged', 'id', id)
            const localVarPath = `/api/v4/projects/{id}/repository/merged_branches`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/merged_branches',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project repository branches
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} [page] Current page number
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Return list of branches matching the search criteria
         * @param {string} [regex] Return list of branches matching the regex
         * @param {'name_asc' | 'updated_asc' | 'updated_desc'} [sort] Return list of branches sorted by the given field
         * @param {string} [pageToken] Name of branch to start the pagination from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (id: string, page?: number, perPage?: number, search?: string, regex?: string, sort?: 'name_asc' | 'updated_asc' | 'updated_desc', pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAll', 'id', id)
            const localVarPath = `/api/v4/projects/{id}/repository/branches`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (regex !== undefined) {
                localVarQueryParameter['regex'] = regex;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single repository branch
         * @param {string} id The ID or URL-encoded path of the project
         * @param {number} branch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBranch: async (id: string, branch: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSingleBranch', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getSingleBranch', 'branch', branch)
            const localVarPath = `/api/v4/projects/{id}/repository/branches/{branch}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch !== undefined ? branch : `-branch-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches/{branch}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Protect a single branch
         * @param {string} id The ID or URL-encoded path of the project
         * @param {string} branch The name of the branch
         * @param {BranchesProtectBranchRequest} [branchesProtectBranchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectBranch: async (id: string, branch: string, branchesProtectBranchRequest?: BranchesProtectBranchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('protectBranch', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('protectBranch', 'branch', branch)
            const localVarPath = `/api/v4/projects/{id}/repository/branches/{branch}/protect`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch !== undefined ? branch : `-branch-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: branchesProtectBranchRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches/{branch}/protect',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(branchesProtectBranchRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unprotect a single branch
         * @param {string} id The ID or URL-encoded path of the project
         * @param {string} branch The name of the branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unprotectBranch: async (id: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unprotectBranch', 'id', id)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('unprotectBranch', 'branch', branch)
            const localVarPath = `/api/v4/projects/{id}/repository/branches/{branch}/unprotect`
                .replace(`{${"id"}}`, encodeURIComponent(String(id !== undefined ? id : `-id-`)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch !== undefined ? branch : `-branch-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Private-Token", keyParamName: "apiKeyAuth", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/v4/projects/{id}/repository/branches/{branch}/unprotect',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if a branch exists
         * @param {BranchesApiCheckIfExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIfExists(requestParameters: BranchesApiCheckIfExistsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIfExists(requestParameters.id, requestParameters.branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create branch
         * @param {BranchesApiCreateBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBranch(requestParameters: BranchesApiCreateBranchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBranch(requestParameters.id, requestParameters.branch, requestParameters.ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a branch
         * @param {BranchesApiDeleteBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranch(requestParameters: BranchesApiDeleteBranchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranch(requestParameters.id, requestParameters.branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all merged branches
         * @param {BranchesApiDeleteMergedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMerged(requestParameters: BranchesApiDeleteMergedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMerged(requestParameters.id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a project repository branches
         * @param {BranchesApiGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(requestParameters: BranchesApiGetAllRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIEntitiesBranch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(requestParameters.id, requestParameters.page, requestParameters.perPage, requestParameters.search, requestParameters.regex, requestParameters.sort, requestParameters.pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single repository branch
         * @param {BranchesApiGetSingleBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleBranch(requestParameters: BranchesApiGetSingleBranchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleBranch(requestParameters.id, requestParameters.branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Protect a single branch
         * @param {BranchesApiProtectBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async protectBranch(requestParameters: BranchesApiProtectBranchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesBranch>> {
            const branchesProtectBranchRequest: BranchesProtectBranchRequest = {
                developers_can_push: requestParameters.developers_can_push,
                developers_can_merge: requestParameters.developers_can_merge
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.protectBranch(requestParameters.id, requestParameters.branch, branchesProtectBranchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unprotect a single branch
         * @param {BranchesApiUnprotectBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unprotectBranch(requestParameters: BranchesApiUnprotectBranchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIEntitiesBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unprotectBranch(requestParameters.id, requestParameters.branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * Check if a branch exists
         * @param {BranchesApiCheckIfExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIfExists(requestParameters: BranchesApiCheckIfExistsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkIfExists(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create branch
         * @param {BranchesApiCreateBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranch(requestParameters: BranchesApiCreateBranchRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesBranch> {
            return localVarFp.createBranch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a branch
         * @param {BranchesApiDeleteBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(requestParameters: BranchesApiDeleteBranchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBranch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all merged branches
         * @param {BranchesApiDeleteMergedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerged(requestParameters: BranchesApiDeleteMergedRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMerged(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a project repository branches
         * @param {BranchesApiGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(requestParameters: BranchesApiGetAllRequest, options?: AxiosRequestConfig): AxiosPromise<Array<APIEntitiesBranch>> {
            return localVarFp.getAll(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single repository branch
         * @param {BranchesApiGetSingleBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleBranch(requestParameters: BranchesApiGetSingleBranchRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesBranch> {
            return localVarFp.getSingleBranch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Protect a single branch
         * @param {BranchesApiProtectBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protectBranch(requestParameters: BranchesApiProtectBranchRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesBranch> {
            return localVarFp.protectBranch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Unprotect a single branch
         * @param {BranchesApiUnprotectBranchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unprotectBranch(requestParameters: BranchesApiUnprotectBranchRequest, options?: AxiosRequestConfig): AxiosPromise<APIEntitiesBranch> {
            return localVarFp.unprotectBranch(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkIfExists operation in BranchesApi.
 * @export
 * @interface BranchesApiCheckIfExistsRequest
 */
export type BranchesApiCheckIfExistsRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiCheckIfExists
    */
    readonly id: string
    
    /**
    * The name of the branch
    * @type {string}
    * @memberof BranchesApiCheckIfExists
    */
    readonly branch: string
    
}

/**
 * Request parameters for createBranch operation in BranchesApi.
 * @export
 * @interface BranchesApiCreateBranchRequest
 */
export type BranchesApiCreateBranchRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiCreateBranch
    */
    readonly id: string
    
    /**
    * The name of the branch
    * @type {string}
    * @memberof BranchesApiCreateBranch
    */
    readonly branch: string
    
    /**
    * Create branch from commit sha or existing branch
    * @type {string}
    * @memberof BranchesApiCreateBranch
    */
    readonly ref: string
    
}

/**
 * Request parameters for deleteBranch operation in BranchesApi.
 * @export
 * @interface BranchesApiDeleteBranchRequest
 */
export type BranchesApiDeleteBranchRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiDeleteBranch
    */
    readonly id: string
    
    /**
    * The name of the branch
    * @type {string}
    * @memberof BranchesApiDeleteBranch
    */
    readonly branch: string
    
}

/**
 * Request parameters for deleteMerged operation in BranchesApi.
 * @export
 * @interface BranchesApiDeleteMergedRequest
 */
export type BranchesApiDeleteMergedRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiDeleteMerged
    */
    readonly id: string
    
}

/**
 * Request parameters for getAll operation in BranchesApi.
 * @export
 * @interface BranchesApiGetAllRequest
 */
export type BranchesApiGetAllRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiGetAll
    */
    readonly id: string
    
    /**
    * Current page number
    * @type {number}
    * @memberof BranchesApiGetAll
    */
    readonly page?: number
    
    /**
    * Number of items per page
    * @type {number}
    * @memberof BranchesApiGetAll
    */
    readonly perPage?: number
    
    /**
    * Return list of branches matching the search criteria
    * @type {string}
    * @memberof BranchesApiGetAll
    */
    readonly search?: string
    
    /**
    * Return list of branches matching the regex
    * @type {string}
    * @memberof BranchesApiGetAll
    */
    readonly regex?: string
    
    /**
    * Return list of branches sorted by the given field
    * @type {'name_asc' | 'updated_asc' | 'updated_desc'}
    * @memberof BranchesApiGetAll
    */
    readonly sort?: 'name_asc' | 'updated_asc' | 'updated_desc'
    
    /**
    * Name of branch to start the pagination from
    * @type {string}
    * @memberof BranchesApiGetAll
    */
    readonly pageToken?: string
    
}

/**
 * Request parameters for getSingleBranch operation in BranchesApi.
 * @export
 * @interface BranchesApiGetSingleBranchRequest
 */
export type BranchesApiGetSingleBranchRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiGetSingleBranch
    */
    readonly id: string
    
    /**
    * 
    * @type {number}
    * @memberof BranchesApiGetSingleBranch
    */
    readonly branch: number
    
}

/**
 * Request parameters for protectBranch operation in BranchesApi.
 * @export
 * @interface BranchesApiProtectBranchRequest
 */
export type BranchesApiProtectBranchRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiProtectBranch
    */
    readonly id: string
    
    /**
    * The name of the branch
    * @type {string}
    * @memberof BranchesApiProtectBranch
    */
    readonly branch: string
    
} & BranchesProtectBranchRequest

/**
 * Request parameters for unprotectBranch operation in BranchesApi.
 * @export
 * @interface BranchesApiUnprotectBranchRequest
 */
export type BranchesApiUnprotectBranchRequest = {
    
    /**
    * The ID or URL-encoded path of the project
    * @type {string}
    * @memberof BranchesApiUnprotectBranch
    */
    readonly id: string
    
    /**
    * The name of the branch
    * @type {string}
    * @memberof BranchesApiUnprotectBranch
    */
    readonly branch: string
    
}

/**
 * BranchesApiGenerated - object-oriented interface
 * @export
 * @class BranchesApiGenerated
 * @extends {BaseAPI}
 */
export class BranchesApiGenerated extends BaseAPI {
    /**
     * Check if a branch exists
     * @param {BranchesApiCheckIfExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public checkIfExists(requestParameters: BranchesApiCheckIfExistsRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).checkIfExists(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create branch
     * @param {BranchesApiCreateBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public createBranch(requestParameters: BranchesApiCreateBranchRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).createBranch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a branch
     * @param {BranchesApiDeleteBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public deleteBranch(requestParameters: BranchesApiDeleteBranchRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).deleteBranch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all merged branches
     * @param {BranchesApiDeleteMergedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public deleteMerged(requestParameters: BranchesApiDeleteMergedRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).deleteMerged(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a project repository branches
     * @param {BranchesApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public getAll(requestParameters: BranchesApiGetAllRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).getAll(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single repository branch
     * @param {BranchesApiGetSingleBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public getSingleBranch(requestParameters: BranchesApiGetSingleBranchRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).getSingleBranch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Protect a single branch
     * @param {BranchesApiProtectBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public protectBranch(requestParameters: BranchesApiProtectBranchRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).protectBranch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unprotect a single branch
     * @param {BranchesApiUnprotectBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApiGenerated
     */
    public unprotectBranch(requestParameters: BranchesApiUnprotectBranchRequest, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).unprotectBranch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
